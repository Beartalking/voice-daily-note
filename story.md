# Voice Daily Note：从手动拼接到一键出稿

## Situation（背景）

我每天用录音笔和 iPhone Voice Memo 记录语音笔记——通勤路上的灵感、对生活的思考、工作中的碎碎念。这些录音会在电脑上积压一周甚至更久。

之前的处理流程是纯手动的：先用 Buzz 桌面端逐个转录音频，然后手动把所有文本合并成一个大文件，再丢给 LLM 做精修（修错别字、分段、加标题），最后还要按日期手动切割成每日笔记，存入 Obsidian。

一周的录音大概 4-8 个文件，整个流程走下来要花 30-60 分钟的纯操作时间，而且每一步都容易出错：忘记某个文件、日期分错组、精修后漏掉某条记录。

## Task（目标）

把这个五步手动流程压缩成**一条命令**：

```
录音文件 → 自动转录 → 自动按天分组 → Claude API 精修 → 每日一个 MD 文件
```

核心约束：
- 零删减——精修只改错别字和格式，不许丢内容
- 幂等——中断后重新跑，自动跳过已完成的步骤
- 零新依赖——只用机器上已有的工具（Buzz、whisper、requests）
- 支持夜间无人值守运行

## Action（行动）

### 架构设计

将流水线拆成三个独立模块，每个模块可单独运行：

1. **transcribe.py**：封装 Buzz CLI 作为主转录引擎，whisper Python 库作为自动降级方案。支持两种文件名格式的时间戳提取（录音笔的 `YYYYMMDD_HHMMSS` 和 Voice Memo 的 `YYYYMMDD-N`）。

2. **refine.py**：读取转录文本，按日期分组，每天构建一个 Claude API 请求。使用 Sonnet 4.5 模型，直接通过 `requests` 调用 HTTP API，内置指数退避重试。输出带 YAML front matter 的 Markdown 文件。

3. **pipeline.py**：编排入口，串联转录→精修→归档三个步骤，支持 `--dry-run`、`--force`、`--step`、`--no-archive` 等参数。

### 关键问题与解决

**Buzz CLI 假成功**：Buzz 对某些文件返回 exit code 0 但不生成输出文件。解决方案：在判断成功前，额外验证输出文件是否实际存在且非空。

**Buzz 超时误判**：初始设置 10 分钟超时，导致较长录音被误判为失败并回退到更慢的 whisper。将超时调整到 30 分钟后，Buzz 的成功率大幅提升。

**Python 3.9 兼容性**：macOS 自带 Python 3.9 不支持 `str | None` 等 3.10+ 语法。通过 `from __future__ import annotations` 一行解决。

### 夜间运行方案

编写 `run-overnight.sh`，使用 `caffeinate` 阻止 Mac 休眠 + `nohup` 脱离终端 + 日志文件记录 + macOS 原生通知（完成后弹窗提醒并播放提示音）。睡前一条命令启动，早上醒来看通知即可。

## Result（成果）

### 量化效果

| 指标 | 手动流程 | 自动流水线 |
|------|---------|-----------|
| 处理 4 个录音的操作时间 | 30-60 分钟 | 1 条命令，0 分钟操作 |
| 出错风险（漏文件、日期分错） | 高 | 零（自动化） |
| 中断恢复 | 从头来 | 断点续跑 |
| 支持积压天数 | 费力 | 无限（自动按天分组） |

### 首次实战

用 4 个真实录音文件（跨 3 天：2月8日、9日、10日）完成端到端验证：
- 4 个 WAV 全部成功转录（2 个 Buzz 直出，2 个自动降级到 whisper）
- 3 个精修后的每日 MD 文件生成，格式正确，内容完整
- 幂等性验证通过：第二次运行自动跳过已完成文件，仅补充缺失的 2月9日

### 代码规模

5 个 Python 模块 + 1 个 Shell 脚本，总计约 400 行代码。零新依赖安装。从设计到实战验证通过，一个会话内完成。
